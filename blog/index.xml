<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on RainPot Blog</title>
    <link>/blog/</link>
    <description>Recent content in Blogs on RainPot Blog</description>
    
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简单介绍YoloV7原理及使用</title>
      <link>/blog/yolov7%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/yolov7%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</guid>
      <description>1.YoloV7 论文名称：《YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors》 论文地址： https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/2207.02696.pdf 论文代码： https://link.zhihu.com/?target=https%3A//github.com/WongKinYiu/yolov7
YoloV7是由YoloV4团队提出的检测器，目前在速度与精度上有不小的优势。作者称YOLOv7 在 5 FPS 到 160 FPS 范围内，速度和精度都超过了所有已知的目标检测器，并在 GPU V100 上，30 FPS 的情况下达到实时目标检测器的最高精度 56.8% AP。 整体模型如下图： 2.改进点 1.Model re-parametrization techniques(重参化技术) 对应架构图当中的REP模块。我们可通过RepVGG: make VGG great again!来快速理解什么为重参化技术。浅显地总结下：对于一个多分支block，可通过一定的方式将多分支合并为单分支，减少参数量同时提升效果。在RepVGG中，RepConv定义如下图，总结下就是一个3x3卷积 一个1x1卷积和一个恒等映射，可以压缩为一个单一的3x3卷积： 2.ELAN ELAN-W E-ELAN 对于ELAN，可通过下面这个博客进行了解：理解Yolov7使用的ELAN，目标是为了从梯度路径层面优化模型效果。 ELAN-W模块，与ELAN所略有不同的是它在第二条分支的时候选取的输出数量不同。 E-ELAN，其主要架构如下图所示。在大规模ELAN中，无论梯度路径长度和计算模块数量如何，都达到了稳定的状态。但如果更多计算模块被无限地堆叠，这种稳定状态可能会被破坏，参数利用率也会降低。本文提出的E-ELAN采用expand、shuffle、merge cardinality结构，实现在不破坏原始梯度路径的情况下，提高网络的学习能力。 3.Model scaling for concatenation-based models 模型缩放通过改变模型的宽度、深度和分辨率来生成不同大小的模型。 如果将上述E-EALN方法应用到基于级联的模型，我们会发现，当对深度放大或缩小时，基于级联的计算模块之后的过渡层的通道会随之减少或增加。如下图a-&amp;gt;b所示。 如果按比例放大深度，这种行为会导致过渡层的深入通道和输出通道的比例会变化，从而导致模型的硬件使用量下降。因此，对于基于级联的模型，必须提出一种复合模型缩放方法。即同时考虑深度因子以及过渡层的宽度因子。如上图(c)所示。
4.辅助Loss及标签分配 辅助头（Aux head）指使用网络中间层进行损失计算来辅助网络训练（深度监督：监督网络不同深度特征）。如图（a）无辅助头。图（b）有辅助头。一般来说，在训练时增加辅助头可带来更好的性能，在推理时，去掉辅助头，加快模型推理速度。 本文作者将负责最终预测的head称为lead head，用于辅助训练的head称为aux head。用于训练两个head的样本分配策略如图（d）和（e）所示。 在过去，在深度网络的训练中，标签分配通常直接指的是ground truth，并根据给定的规则生成hard label（未经过softmax）。然而近年来，以目标检测为例，研究者经常利用网络预测的质量分布来结合ground truth，使用一些计算和优化方法来生成可靠的软标签（soft label）。例如，YOLO使用bounding box预测和ground truth的IoU作为软标签。在本文中，作者将网络预测结果与ground truth一起考虑后再分配软标签的机制称为“标签分配器”。无论辅助头或引导头，都需要对目标进行深度监督。那么，‘’如何为辅助头和引导头合理分配软标签？”，这是作者需要考虑的问题。目前最常用的方法如图5（c）所示，即将辅助头和引导头分离，然后利用它们各自的预测结果和ground truth执行标签分配。本文提出的方法是一种新的标签分配方法，通过引导头的预测来引导辅助头以及自身。换句话说，首先使用引导头的prediction作为指导，生成从粗到细的层次标签，分别用于辅助头和引导头的学习，具体可看图5(d)和(e)。</description>
    </item>
    
    <item>
      <title>本地多Git账户配置</title>
      <link>/blog/%E6%9C%AC%E5%9C%B0%E5%A4%9Agit%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E6%9C%AC%E5%9C%B0%E5%A4%9Agit%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/</guid>
      <description>1.多git需求 大部分人会有本地多git账号需求，用来管理不同git归属仓库(如公司/学校/github等代码托管平台)，简单记录下配置过程。
2.git ssh机制 在gitlab，github上面拷贝代码时，通常用到了git clone ssh://XXX命令。其中ssh指secure shell（一种安全的网络协议），git使用这种协议进行远程加密登录。 git使用SSH配置， 初始需要以下三个步骤
使用秘钥生成工具生成rsa秘钥和公钥 将rsa公钥添加到代码托管平台 将rsa秘钥添加到ssh-agent中，为ssh client指定使用的秘钥文件
3.具体步骤 比如当前需要管理两个git账户
a.生成两个密钥 首先我们需要两个ssh密钥，对应你的两个身份(假设为public和private) 如果使用过git的话，我们基本已经拥有一个密钥了，比如通过以下命令生成了密钥： ssh-keygen -t rsa -C “youremail@gmail.com”生成了id_rsa与id_rsa.pub，保存在了 ~/.ssh/目录下。 然后我们需要再使用另外一个邮箱账号生成另外一个密钥，ssh-keygen -t rsa -C “private_mail@gmail.com”，⚠️注意此时需要重命名，否则会覆盖我们之前已经在使用的密钥。重命名后假设我们生成了private_id_rsa与private_id_rsa.pub。不要忘记将此private密钥加入到你的第二个git托管平台中。
b.编辑ssh配置文件 编辑~/.ssh/config文件。如果该文件不存在的话，直接创建一个就好。内容如下：
# 原有，假设为github Host github_public Hostname ssh.github.com IdentityFile ~/.ssh/id_rsa port 22 # 新增，刚添加的第二个git账号 Host git_private Hostname ssh.sankuai.com IdentityFile ~/.ssh/private_id_rsa port 22 修改完之后，在git bash运行以下命令（@后面的主机名为上面配置文件中填写的Host），检查是否正常。
**（注意：不要忘记将新增的密钥添加到对应的git托管平台）
ssh -T git@github_public ssh -T git@git_private 如果能正常返回，就说明配置正常。
同样的方式你就可以配置更多的以SSH登录的不同git用户。
c.使用 通过变换不同的Host，就可以自由使用期望的账号进行git clone及新建仓库了。 比如我要以公司账号clone与使用公司仓库，可以使用：
git clone git@git_private:RainPot/RainPot.sankuai.git </description>
    </item>
    
    <item>
      <title>Windows Terminal</title>
      <link>/blog/windows-terminal/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/windows-terminal/</guid>
      <description>记录Windows Terminal配置过程
Windows Terminal Windows Terminal 作为一名新晋的Windows终端，当然要来试一下。 目前Windows Terminal已经趋于成熟，个人感觉已经可以让它成为主力终端， 它实现了社区用户热切期望的许多功能(如多标签、主题样式、可配置性、富文本等)，并保持了快速与高效，不会消耗大量内存与电量。下面简单记录一下配置过程。
Windows Ternimal GitRep
Windows Terminal Installation Windows Terminal已经在微软商店上架，如果可已登录microsoft store，直接在商店搜索安装即可。
如果没有办法使用，可以在release 下载Microsoft.WindowsTerminal_1.1.1671.0_8wekyb3d8bbwe.msixbundle直接安装即可。
也可以用chocolatey安装：
choco install microsoft-windows-terminal 安装好后，WT的界面是有些丑的&amp;hellip; 下面讲一下如何进一步配置WT。
Windows Terminal Settings 首先我们要进入Windows Terminal的配置文件，在下拉菜单中，选择设置/Settings，这一操作会使用系统默认文本编辑器打开Windows Terminal的配置文件。 配置文件是一个JSON格式文件，我们可以在其中定义全部Windows Terminal的属性。 结构非常清晰，大致上，配置包含如下几个部分：
全局属性：位于最外侧，包含设置亮暗主题、默认Profile等项目的配置。 profiles：主要功能为定义从下拉菜单中唤起的各种环境(如PowerShell，WSL，cmd等)，以及各种环境的显示方案(主题、背景、字体等)。 schemes：配色主题，可以去iTerm2-Color-Schemes里找喜欢的 keybindings：自定义快捷键的绑定。 Appearance Configuration 调整背景
Windows Terminal的背景可以是一种纯色，也可以是一张高清壁纸，GIF动图等。纯色背景可以直接设为默认，也可以根据你的colorSchemes(我们的配色主题)改变，也可以在profiles的每个环境里面单独设置。同时我们让背景添加透明的亚克力着色，就可以使用下面三条指令：
&amp;#34;profiles&amp;#34;: { &amp;#34;defaults&amp;#34;: { // Put settings here that you want to apply to all profiles. &amp;#34;background&amp;#34;: &amp;#34;#013456&amp;#34;, &amp;#34;useAcrylic&amp;#34;: true, &amp;#34;acrylicOpacity&amp;#34;: 0.8 }, 当然我们也可以让一张图片作为背景，我们首先进入Windows Terminal安装目录C:\Users\{用户名}\AppData\Local\Packages\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe里面的RoamingState文件夹，将壁纸放入其中。之后在配置文件加入以下内容：</description>
    </item>
    
    <item>
      <title>剑指offer61-67</title>
      <link>/blog/%E5%89%91%E6%8C%87offer61-67/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer61-67/</guid>
      <description>61题目描述 序列化二叉树
请实现两个函数，分别用来序列化和反序列化二叉树
二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。
二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。
思路 采用前序遍历，遇到空节点，存入一个特殊字符。运用递归。要熟练使用to_string() 及 stoi()，c_str() strcpy() substr() 的用法。
代码 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public: void SerializeHelper(TreeNode *root, string &amp;amp;str) { if(root == NULL) { str += &amp;#34;N,&amp;#34;; return; } str += to_string(root -&amp;gt; val); str += &amp;#34;,&amp;#34;; SerializeHelper(root -&amp;gt; left, str); SerializeHelper(root -&amp;gt; right, str); } char* Serialize(TreeNode *root) { if(root == NULL) return NULL; string s = &amp;#34;&amp;#34;; SerializeHelper(root, s); char* ret = new char[s.</description>
    </item>
    
    <item>
      <title>剑指offer51-60</title>
      <link>/blog/%E5%89%91%E6%8C%87offer51-60/</link>
      <pubDate>Thu, 16 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer51-60/</guid>
      <description>51题目描述 构建乘积数组
给定一个数组A[0,1,&amp;hellip;,n-1],请构建一个数组B[0,1,&amp;hellip;,n-1],其中B中的元素B[i]=A[0]A[1]&amp;hellip;*A[i-1]A[i+1]&amp;hellip;*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * &amp;hellip; * A[n-1]，B[n-1] = A[0] * A[1] * &amp;hellip; * A[n-2];）
思路1 直接暴力两个循环。。
代码 class Solution { public: vector&amp;lt;int&amp;gt; multiply(const vector&amp;lt;int&amp;gt;&amp;amp; A) { vector&amp;lt;int&amp;gt; result; int temp = 1; if(A.size() == 0) return result; for(int i = 0; i &amp;lt; A.size(); i++) { temp = 1; for(int j = 0; j &amp;lt; A.size(); j++) { if(j == i) continue; else { temp *= A[j]; } } result.</description>
    </item>
    
    <item>
      <title>剑指offer41-50</title>
      <link>/blog/%E5%89%91%E6%8C%87offer41-50/</link>
      <pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer41-50/</guid>
      <description>41题目描述 和为S的连续正数序列
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
输出描述:
输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
思路 采用双指针策略，不需要使用队列，用队列反而变麻烦了。记录两个指针，一个大一个小，计算大小之间这个窗口的和。
代码 class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; FindContinuousSequence(int sum) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; Sequences; if(sum &amp;lt; 3) return Sequences; int small = 1; int big = 2; int temp_sum = 3; int mid = (sum + 1) / 2; while(small &amp;lt; mid) { if(temp_sum == sum) { vector&amp;lt;int&amp;gt; temp_sequence; for(int i = small; i &amp;lt;= big; i++) temp_sequence.push_back(i); Sequences.push_back(temp_sequence); } if(temp_sum &amp;gt; sum) { while(temp_sum &amp;gt; sum &amp;amp;&amp;amp; small &amp;lt; mid) { temp_sum -= small; small++; } if(temp_sum == sum) { vector&amp;lt;int&amp;gt; temp_sequence; for(int i = small; i &amp;lt;= big; i++) temp_sequence.</description>
    </item>
    
    <item>
      <title>剑指offer31-40</title>
      <link>/blog/%E5%89%91%E6%8C%87offer31-40/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer31-40/</guid>
      <description>31题目描述 整数中1出现的次数（从1到n整数中1出现的次数）
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
思路 注意审题，1出现的次数，不是包含1的数有多少个。 问题不要想复杂了，使用简单的模10即可解决。
代码 class Solution { public: int NumberOf1Between1AndN_Solution(int n) { int num = 0; if(n &amp;lt; 1) return 0; for(int i = 1; i &amp;lt;= n; i++) { int temp = i; while(temp) { if(temp % 10 == 1) num++; temp = temp / 10; } } return num; } }; 32题目描述 把数组排成最小的数：
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
思路 用vector自带sort函数进行排序，顺序由自己重新定义：a b转换成string后进行比较，ab&amp;lt;ba则保持顺序不变，ab&amp;gt;ba表示后面的要放到前面。这里需要熟悉vector的sort函数以及to_string，string之间的比较。https://blog.csdn.net/ihadl/article/details/7400929
代码 class Solution { public: static bool exchange(int i, int j) { string A = &amp;#34;&amp;#34;; string B = &amp;#34;&amp;#34;; A += to_string(i); A += to_string(j); B += to_string(j); B += to_string(i); return A &amp;lt; B; } string PrintMinNumber(vector&amp;lt;int&amp;gt; numbers) { string result = &amp;#34;&amp;#34;; if(numbers.</description>
    </item>
    
    <item>
      <title>剑指offer21-30</title>
      <link>/blog/%E5%89%91%E6%8C%87offer21-30/</link>
      <pubDate>Tue, 31 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer21-30/</guid>
      <description>21题目描述 栈的压入、弹出序列：
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
思路 我想的思路是借用一个辅助栈，进行真实的入栈出栈，判断第二个序列与栈顶是否相同，如果不相同，则进行序列1的压入栈。在压入是判断压入的是否与序列2当前元素相等，如果相等，则视为直接出栈，然后返回来判断序列2的下一个元素是否与栈顶相等，相等的话则pop，序列2继续往后走，以此循环。最后判断辅助栈是否为空，如果为空，则出栈顺序没毛病，返回1，如果不为空，则出栈不符合规则，返回0；
代码 class Solution { public: bool IsPopOrder(vector&amp;lt;int&amp;gt; pushV,vector&amp;lt;int&amp;gt; popV) { stack&amp;lt;int&amp;gt; aux; if(pushV.size() != popV.size()) return false; if(pushV.empty() || popV.empty()) return false; int i = 0, j = 0; for(; i &amp;lt; pushV.size() &amp;amp;&amp;amp; j &amp;lt; popV.size();) { if(aux.empty()) { aux.push(pushV[i]); i++; continue; } if(aux.top() != popV[j]) { for(; i &amp;lt; pushV.size(); ) { if(pushV[i] != popV[j]) { aux.push(pushV[i]); i++; } if(pushV[i] == popV[j]) { i++; j++; break; } } continue; } if(aux.</description>
    </item>
    
    <item>
      <title>剑指offer11-20</title>
      <link>/blog/%E5%89%91%E6%8C%87offer11-20/</link>
      <pubDate>Wed, 25 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer11-20/</guid>
      <description>11题目描述 二进制中1的个数：
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
思路 首先要明白几个常识 1.计算机中整数都是以补码存储，所以此题不需考虑正负问题 2.按位与操作&amp;amp;要熟悉。
题解思路：如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
代码 class Solution { public: int NumberOf1(int n) { int count = 0; while(n != 0) { count++; n = n &amp;amp; (n - 1); } return count; } }; 12题目描述 数值的整数次方：
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
保证base和exponent不同时为0
思路 本题看题解 如果不用pow函数则需要充分考虑base exponent的各种极端情况， 我使用了pow函数，直接ac了。。
代码 class Solution { public: double Power(double base, int exponent) { //if(base == 0) return 0.0; //if(exponent == 0) return 1.0; return pow(base, exponent); } }; 13题目描述 调整数组顺序使奇数位于偶数前面：</description>
    </item>
    
    <item>
      <title>剑指offer01-10</title>
      <link>/blog/%E5%89%91%E6%8C%87offer01-10/</link>
      <pubDate>Mon, 23 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%89%91%E6%8C%87offer01-10/</guid>
      <description>01题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路 注意这个数组的特点，从左到右递增，从上到下递增，我的思路是利用这个特点进行最简单的遍历查找。
一行一行进行比较，首先从第一行开始，判断行的首元素与target大小，如果首元素大，直接判定数组不包涵此target，如果相等返回true，如果首元素小，从行末往前进行遍历，判断target与每个元素大小，如果元素大，继续向前比，如果元素小，跳出循环进行下一行的比较
**注意！！**编好之后一直堆栈溢出，才发现是没有判断数组是否为空，这点以后一定要注意。
代码 class Solution { public: bool Find(int target, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; array) { if (array.empty())return false; for(int i=0;i &amp;lt; array.size(); i++) { if(array[i].empty())continue; if(array[i][0] &amp;gt; target) return false; else if(target == array[i][0]) return true; else if(target &amp;gt; array[i][0]) { for(int j=(array[i].size() - 1);j&amp;gt;0;j--) { if(target == array[i][j]) return true; else if(target &amp;lt; array[i][j]) continue; else if(target &amp;gt; array[i][j]) break; } } } return false; } }; 02题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.</description>
    </item>
    
    <item>
      <title>AGSS-VOS: Attention Guided Single-Shot Video Object Segmentation 论文解读</title>
      <link>/blog/agss-vos/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/agss-vos/</guid>
      <description>&lt;p&gt;此篇文章为iccv2019中关于视频分割的一篇文章，主要针对多物体进行视频object分割，值得一读&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>实用的数据结构</title>
      <link>/blog/%E5%AE%9E%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/blog/%E5%AE%9E%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;课程第一章 实用的数据结构&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VisDrone2019记录</title>
      <link>/blog/visdrone2019/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/visdrone2019/</guid>
      <description>简单介绍本组VisDrone2019比赛Object Detection in Images任务所采用的算法方法。
Introduction RRNet 本次比赛提出并采用的网络框架为——RRNet，主要思想为将单阶段anchor-free算法(CenterNet)通过再次回归变为二阶段算法，通过再回归的方式让本就较精确的bbox更加精准。下图为网络框架图：
RRNet Struecture 网络主体为CenterNet,backbone为hourglass-104，两个hourglass block的输出全部参与分类及回归，Heatmap代表中心点的激活图，Size代表中心点所对应object长宽的激活图，输出的一共4个map分别进行focal loss和l1 loss的计算。此上为CenterNet的主要部分，接下来我们继续利用其输出的特征图，送入后面的Re-Regression Module进行二次回归。Re-Regression Module内部结构如下：
Re-Regression Module 通过CenterNet生成的Heatmap以及SIzemap，我们可以直接将其转换成为bbox，得到bbox之后(我们可以将其类比为faster-rcnn中RPN网络生成的候选框)，我们将这些候选区域送入ROI Align，进行再一次回归得到偏移量，将此偏移量加到原始bbox上的到修正后的输出。
Major features 除了再回归网络，我们还采用了以下一些方法让性能进一步提升：
method mAP 1.two-stage/multi-stage ↑2% 2.wh conv ↑0.3% 3.re-sample ↑1% 4.multiscale training/test ↑2% 5.sync training ↑1% 6.nms/soft nms ↑1% 7.KL-Loss (↑1%?) 8.warm up lr - 9.mix up - 10.ellipse gaussian - Details 1.two-stage/multi-stage two-stage便指再回归思想，对于进行多次回归(multi-stage)我们目前还没有进行实验。这个再回归让mAP提高了2%
2.wh conv 对于CenterNet中SIzemap的回归是单纯使用3x3卷积，我们认为这种卷积核并不能get到整个object的全部信息，从而以这种方式推理出object的长与宽是不合理的，于是我们采用1xk，kx1的卷积核分别推理object的宽和长，这样可能会获得更多有效信息。 此方法提升了0.3%的mAP。
wh conv 3.Data Augmentation 简单介绍一下数据增强方面所采用的一些方法
re-sample 我们发现对于people，pedestrian等小目标的类准确率非常低，于是采用了将hard-sample再次采样(复制)放到图上进行训练的方式。考虑到背景信息，我们首先使用在Cityscapes数据集上训好的deeplabv3以及图像腐蚀+中值滤波在我们自己的无人机数据集上分割出道路，这样复制出的人，自行车一类就可以让他们放在道路上而不是天上或楼上。
与此同时，由于镜头视角的缘故，在同一张图片中一个人的大小是不同的，直接复制出来填到任意一个地方也是不合理的，于是我们为了解决这个问题，首先在图中找到一个像素h(高度)最矮的一个人，同时再找三个h最高的人，建立一个人的高度h与图片像素位置H的线性关系，这样就可以根据要插入的位置，计算人应有的高度放进去也就不违和了。
multiscale training/test 此方法比较普遍，就不过多介绍了，基本对于任何算法(检测、分割)都可以提升最终的准确率。</description>
    </item>
    
    <item>
      <title>Pytorch Tensorboard</title>
      <link>/blog/torchtensorboard/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/torchtensorboard/</guid>
      <description>&lt;p&gt;Pytorch Tensorboard的简单使用
&lt;img src=&#34;/images/tensorboard01.png&#34; alt=&#34;preview&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DANet-CCNet</title>
      <link>/blog/danet-ccnet/</link>
      <pubDate>Mon, 21 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/danet-ccnet/</guid>
      <description>&lt;p&gt;两篇文章都是将self-attention机制应用到分割当中，扩大感受野。第二篇文章采用了更巧妙的方法来减少参数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Context Encoding for Semantic Segmentation</title>
      <link>/blog/context-encoding-for-semantic-segmentation/</link>
      <pubDate>Fri, 06 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/context-encoding-for-semantic-segmentation/</guid>
      <description>本文提出了上下文编码模块(Context Encoding Module)引入全局上下文信息(global contextual information)，用于捕获场景的上下文语义并选择性的突出与类别相关的特征图。 实验证明上下文编码模块能够显著的提升语义分割性能，在Pascal-Context上达到了51.7%mIoU, 在 PASCAL VOC 2012上达到了85.9% mIoU，单模型在ADE20K测试集上达到了0.5567。 此外,论文进一步讨论上下文编码模块在相对浅层的网络中提升特征表示的能力，在CIFAR-10数据集上基于14层的网络达到了3.45%的错误率，和比这个多10倍的层的网络有相当的表现。
EncNet introduction 扩张卷积存在的问题 先进的语义分割系统通常是基于FCN架构，采用的深度卷积神经网络受益于从不同图片中学习到的丰富的对象类别信息和场景语义。CNN通过堆叠带非线性激活和下采样的卷积层能够捕获带全局接受野的信息表示，为了克服下采样带来的空间分辨率损失，最近的工作使用扩张卷积策略从预训练模型上产生密集预测。然而，此策略依然会将像素从全局场景上下文相隔开，这会导致像素错误分类。
如下图，错误的将窗格分为门。
金字塔结构存在的问题 近期的工作使用基于金字塔多分辨率表示扩大接受野。例如，PSPNet采用的PSP模块将特征图池化为不同尺寸，再做联接上采样；DeepLab采用ASPP模块并行的使用大扩张率卷积扩大接受野。这些方法都有提升，但是这对上下文表示都不够明确，这出现了一个问题： 捕获上下文信息是否等同于增加接受野大小？
考虑到如下情况，在一个大型数据集上，如下图：
如果能够先捕获到图像上下文信息(例如这是卧室)，然后，这可以提供许多相关小型目标的信息(例如卧室里面有床、椅子等)。这可以动态的减少搜索区域可能。说白了，这就是加入一个场景的先验知识进去，这样对图片中像素分类更有目的性。依照这个思路，可以设计一种方法，充分利用场景上下文和存在类别概率的之间的强相关性，这样语义分割会就容易很多。 能否利用经典方法的上下文编码结合深度学习？ 最近有工作在CNN框架中推广传统编码器方法获得了极大的进步，在本文中，使用扩展编码层来捕获全局特征的统计信息用于理解上下文语义。
contribution 第一个贡献： 引入了上下文编码模块，该单元用于捕获全局场景上下文信息和选择性的突出与类别相关的特征图。 集成了语义编码损失(Semantic Encoding Loss,SE-loss)。 举例来讲，不考虑车辆出现在卧室的可能性，在现有标准的训练过程使用的是像素分割损失，这不强调场景的全局信息。引入语义编码损失(SE-loss)可进一步规范网络训练，让网络预测能够预测场景中对象类别的存在，强化网络学习上下文语义。 与逐像素的损失不同，SE-Loss对于大小不同的物体有相同的贡献，在实践中这能够改善识别小物体的表现。
第二个贡献： 设计了一个新的语义分割架构Context Encoding Network (EncNet)。如下图所示，EncNet通过上下文编码模块增强了预训练的ResNet：
Context Encoding： 对于预训练网络，使用编码层捕获特征图的统计信息作为全局上下文语义，将编码层的输出作为编码语义(encoded semantics)，为了使用上下文，预测了一组放缩因子(scaling factors)用于突出和类别相关的特征图。编码层学习带有上下文语义的固有字典，输出丰富上下文信息的残差编码。
Input feature: CXWXH —&amp;gt;x={x1,x2,&amp;hellip;,xN},N=H×W
Inherent codebook: D={d1,d2,&amp;hellip;,dk}
Scaling factors: S={s1,s2,&amp;hellip;,sk}
最后会输出k个残差编码，
这样做的目的是什么呢？
通过将图像的HXW个C维特征，每一个都与语义词dk做差，然后和所有语义词做差的结果相加进行归一化，获得一个像素位置相对于某个语义词的信息eik，然后将这N个结果求和加在一块获得最终的ek，获得整张图像相对于第k个语义词的信息。
ek是C维的，最后将k个ek融合到一起，这里没有用concat，一方面concat包含了顺序信息，另一方面用加的方法节省了显存。这里加起来的含义是获得整张图像相对于K个语义词的全部信息 ，最后的e也是c维的。
Featuremap Attention： 为了使用编码层捕获的编码语义，预测一组特征图的放缩因子作为循环用于突出需要强调的类别。这样的方法受SE-Net等工作的启发，即考虑强调天空出现飞机，不强调出现车辆的可能性。
Semantic Encoding Loss： 使用Semantic Encoding Loss (SE-loss)在添加少量额外计算消耗的情况下强制网络理解全局语义信息。不同于逐像素损失，SE loss 对于大小不同的目标有相同的贡献，这能够提升小目标的检测性能。
实验结果 Results on PASCAL-Context： Results on ADE20K： Image Classification Results on CIFAR10： </description>
    </item>
    
    <item>
      <title>首次提交</title>
      <link>/blog/firstpost/</link>
      <pubDate>Sun, 11 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/firstpost/</guid>
      <description>&lt;p&gt;blog首次提交测试&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
